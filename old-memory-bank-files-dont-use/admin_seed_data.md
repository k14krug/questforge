 # Admin Seed Data Management

## Overview

This document describes the Admin Seed Data Management screen, accessible via the `/admin` route (link available in the navbar for logged-in users). This screen provides tools for exporting data from existing games into JSON seed files and creating new games based on those seed files, primarily for testing and replication purposes.

## Functionality

### 1. Export Seed Data

*   **Purpose:** To save the state and structure of an existing game into a reusable JSON file.
*   **Interface:**
    *   **Game ID to Export:** Input field for the numeric ID of the game to be exported.
    *   **Seed File Name:** Input field for a descriptive name for the seed file (e.g., `scenario_start`, `mid_game_state`). Only letters, numbers, underscores, and hyphens are allowed. The `.json` extension is added automatically.
    *   **Export Button:** Submits the form to the `/admin/export` endpoint.
*   **Process:**
    1.  The backend route (`admin.export_seed`) receives the `game_id` and `seed_name`.
    2.  It validates the inputs.
    3.  It fetches the `Game` record with the specified ID, along with its related `Campaign`, `GamePlayer` records, and the *latest* `GameState` record.
    4.  It structures the relevant data from these models into a dictionary, removing redundant IDs and potentially sensitive information (like `created_by` from the `Game` data). Datetime objects are converted to ISO format strings.
    5.  The structured dictionary is saved as a JSON file (with pretty-printing) into the `instance/seed_data/` directory, using the provided `seed_name`.
    6.  A success or error message is flashed to the user.
*   **Exported Data:** The JSON file contains:
    *   `exported_at`: Timestamp of export.
    *   `source_game_id`: The ID of the original game.
    *   `game`: Data from the `Game` table.
    *   `campaign`: Data from the `Campaign` table (if exists).
    *   `game_players`: A list of data from the `GamePlayer` table for that game.
    *   `game_state`: Data from the *latest* `GameState` record for that game.

### 2. Import Seed Data (Create Game from Seed)

*   **Purpose:** To create a new game instance based on previously exported seed data.
*   **Interface:**
    *   **Select Seed File:** A dropdown list populated with all `.json` files found in the `instance/seed_data/` directory.
    *   **New Game Name:** Input field for the name of the new game to be created.
    *   **Create Game Button:** Submits the form to the `/admin/import` endpoint.
*   **Process:**
    1.  The backend route (`admin.import_seed`) receives the selected `seed_file` name and the `new_game_name`.
    2.  It validates the inputs.
    3.  It reads and parses the JSON data from the selected file in `instance/seed_data/`.
    4.  It validates the structure of the parsed JSON data.
    5.  It creates new database records:
        *   A new `Game` record is created with the provided `new_game_name`, the `template_id` from the seed data, and the *current logged-in user* as the `created_by`. Other relevant fields (`status`, `max_players`, `creator_customizations`) are copied from the seed data. A **new unique `game_id`** is generated by the database.
        *   If campaign data exists in the seed, a new `Campaign` record is created, linked to the **new `game_id`**.
        *   New `GamePlayer` records are created, linked to the **new `game_id`** and the `user_id`s specified in the seed data (verifying that these users exist).
        *   If game state data exists in the seed, a new `GameState` record is created, linked to the **new `game_id`** and the new `Campaign`'s ID (if applicable). Timestamps (`created_at`, `last_updated`) are reset to the current time.
    6.  All new records are committed to the database in a single transaction.
    7.  A success or error message is flashed to the user, including the ID of the newly created game.

## Notes

*   The `instance/seed_data/` directory is ignored by Git (added to `.gitignore`).
*   Error handling is included for file operations, JSON parsing, missing data, and database errors.
*   Currently, the admin page is protected only by `@login_required`. A specific admin role check can be added later if needed.
*   The import process assumes that related entities like `User` and `Template` referenced by IDs in the seed file already exist in the database.

## Implementation History & Rollback (March 5, 2025)

*   **Initial Attempt:** An initial attempt was made to integrate this admin screen. This involved:
    *   Creating the `admin` blueprint (`views/admin.py`) and template (`templates/admin/admin.html`).
    *   Adding `CSRFProtect` to the application. Initially, this was done by creating an `extensions/` directory with `__init__.py` and separate files for extensions.
    *   Registering the blueprint and initializing CSRF in `questforge/__init__.py`.
    *   Adding a navbar link.
*   **Issues Encountered:** This approach led to `ImportError` and `jinja2.exceptions.UndefinedError` (related to `csrf_token()`). The root cause was determined to be ambiguity and potential circular imports caused by having both `questforge/extensions.py` and a `questforge/extensions/` directory with its own `__init__.py`.
*   **Rollback & Resolution:** To restore a working state, the following actions were taken:
    *   All extension instances (`db`, `bcrypt`, `login_manager`, `migrate`, `socketio`, `init_socketio`) were consolidated into the single `questforge/extensions.py` file.
    *   The `questforge/extensions/` directory and its `__init__.py` were deleted.
    *   Imports across the application (in `__init__.py`, models, services) were updated to point directly to `questforge.extensions`.
    *   The `CSRFProtect` extension additions and the admin blueprint registration were temporarily removed from `__init__.py`.
    *   The admin link was removed from the navbar.
*   **Current Status:** The application is stable with the consolidated `extensions.py`. The task is now to re-integrate the admin functionality correctly using this established extension pattern.
